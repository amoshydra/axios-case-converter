{"version":3,"file":"axios-case-converter.min.js","sources":["../node_modules/tslib/tslib.es6.js","../node_modules/lower-case/dist.es2015/index.js","../node_modules/no-case/dist.es2015/index.js","../node_modules/pascal-case/dist.es2015/index.js","../node_modules/camel-case/dist.es2015/index.js","../node_modules/capital-case/dist.es2015/index.js","../node_modules/upper-case-first/dist.es2015/index.js","../src/decorators.ts","../src/util.ts","../src/transformers.ts","../node_modules/snake-case/dist.es2015/index.js","../node_modules/dot-case/dist.es2015/index.js","../node_modules/header-case/dist.es2015/index.js","../src/middleware.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n */\nvar SUPPORTED_LOCALE = {\n    tr: {\n        regexp: /\\u0130|\\u0049|\\u0049\\u0307/g,\n        map: {\n            İ: \"\\u0069\",\n            I: \"\\u0131\",\n            İ: \"\\u0069\"\n        }\n    },\n    az: {\n        regexp: /\\u0130/g,\n        map: {\n            İ: \"\\u0069\",\n            I: \"\\u0131\",\n            İ: \"\\u0069\"\n        }\n    },\n    lt: {\n        regexp: /\\u0049|\\u004A|\\u012E|\\u00CC|\\u00CD|\\u0128/g,\n        map: {\n            I: \"\\u0069\\u0307\",\n            J: \"\\u006A\\u0307\",\n            Į: \"\\u012F\\u0307\",\n            Ì: \"\\u0069\\u0307\\u0300\",\n            Í: \"\\u0069\\u0307\\u0301\",\n            Ĩ: \"\\u0069\\u0307\\u0303\"\n        }\n    }\n};\n/**\n * Localized lower case.\n */\nexport function localeLowerCase(str, locale) {\n    var lang = SUPPORTED_LOCALE[locale.toLowerCase()];\n    if (lang)\n        return lowerCase(str.replace(lang.regexp, function (m) { return lang.map[m]; }));\n    return lowerCase(str);\n}\n/**\n * Lower case as a function.\n */\nexport function lowerCase(str) {\n    return str.toLowerCase();\n}\n//# sourceMappingURL=index.js.map","import { lowerCase } from \"lower-case\";\n// Support camel case (\"camelCase\" -> \"camel Case\" and \"CAMELCase\" -> \"CAMEL Case\").\nvar DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];\n// Remove all non-word characters.\nvar DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;\n/**\n * Normalize the string into something other libraries can manipulate easier.\n */\nexport function noCase(input, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? \" \" : _d;\n    var result = replace(replace(input, splitRegexp, \"$1\\0$2\"), stripRegexp, \"\\0\");\n    var start = 0;\n    var end = result.length;\n    // Trim the delimiter from around the output string.\n    while (result.charAt(start) === \"\\0\")\n        start++;\n    while (result.charAt(end - 1) === \"\\0\")\n        end--;\n    // Transform each token independently.\n    return result\n        .slice(start, end)\n        .split(\"\\0\")\n        .map(transform)\n        .join(delimiter);\n}\n/**\n * Replace `re` in the input string with the replacement value.\n */\nfunction replace(input, re, value) {\n    if (re instanceof RegExp)\n        return input.replace(re, value);\n    return re.reduce(function (input, re) { return input.replace(re, value); }, input);\n}\n//# sourceMappingURL=index.js.map","import { __assign } from \"tslib\";\nimport { noCase } from \"no-case\";\nexport function pascalCaseTransform(input, index) {\n    var firstChar = input.charAt(0);\n    var lowerChars = input.substr(1).toLowerCase();\n    if (index > 0 && firstChar >= \"0\" && firstChar <= \"9\") {\n        return \"_\" + firstChar + lowerChars;\n    }\n    return \"\" + firstChar.toUpperCase() + lowerChars;\n}\nexport function pascalCaseTransformMerge(input) {\n    return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();\n}\nexport function pascalCase(input, options) {\n    if (options === void 0) { options = {}; }\n    return noCase(input, __assign({ delimiter: \"\", transform: pascalCaseTransform }, options));\n}\n//# sourceMappingURL=index.js.map","import { __assign } from \"tslib\";\nimport { pascalCase, pascalCaseTransform, pascalCaseTransformMerge } from \"pascal-case\";\nexport function camelCaseTransform(input, index) {\n    if (index === 0)\n        return input.toLowerCase();\n    return pascalCaseTransform(input, index);\n}\nexport function camelCaseTransformMerge(input, index) {\n    if (index === 0)\n        return input.toLowerCase();\n    return pascalCaseTransformMerge(input);\n}\nexport function camelCase(input, options) {\n    if (options === void 0) { options = {}; }\n    return pascalCase(input, __assign({ transform: camelCaseTransform }, options));\n}\n//# sourceMappingURL=index.js.map","import { __assign } from \"tslib\";\nimport { noCase } from \"no-case\";\nimport { upperCaseFirst } from \"upper-case-first\";\nexport function capitalCaseTransform(input) {\n    return upperCaseFirst(input.toLowerCase());\n}\nexport function capitalCase(input, options) {\n    if (options === void 0) { options = {}; }\n    return noCase(input, __assign({ delimiter: \" \", transform: capitalCaseTransform }, options));\n}\n//# sourceMappingURL=index.js.map","/**\n * Upper case the first character of an input string.\n */\nexport function upperCaseFirst(input) {\n    return input.charAt(0).toUpperCase() + input.substr(1);\n}\n//# sourceMappingURL=index.js.map","import {\n  ApplyCaseOptions,\n  CaseFunction,\n  PreservedKeysCondition,\n  PreserveSpecificKeys,\n} from \"./types\";\n\nexport const applyCaseOptions: ApplyCaseOptions = (fn, defaultOptions) => {\n  return (input, options?): ReturnType<ReturnType<ApplyCaseOptions>> => {\n    return fn(input, {\n      ...defaultOptions,\n      ...options,\n    });\n  };\n};\n\nexport const preserveSpecificKeys: PreserveSpecificKeys = (\n  fn: CaseFunction,\n  keys: string[] | PreservedKeysCondition\n) => {\n  const condition: PreservedKeysCondition =\n    typeof keys === \"function\"\n      ? keys\n      : (input): boolean => keys.includes(input);\n\n  return (input, options?): ReturnType<ReturnType<PreserveSpecificKeys>> => {\n    return condition(input, options) ? input : fn(input, options);\n  };\n};\n","import { Transformable, TransformableObject } from \"./types\";\n\nexport const isURLSearchParams = (value: unknown): value is URLSearchParams => {\n  return (\n    typeof URLSearchParams !== \"undefined\" && value instanceof URLSearchParams\n  );\n};\n\nexport const isFormData = (value: unknown): value is FormData => {\n  return typeof FormData !== \"undefined\" && value instanceof FormData;\n};\n\nexport const isPlainObject = (value: unknown): value is TransformableObject => {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    Object.prototype.toString.call(value) === \"[object Object]\"\n  );\n};\n\nexport const isTransformable = (value: unknown): value is Transformable => {\n  return (\n    Array.isArray(value) ||\n    isPlainObject(value) ||\n    isFormData(value) ||\n    isURLSearchParams(value)\n  );\n};\n","import {\n  camelCase as camelCaseString,\n  snakeCase as snakeCaseString,\n  headerCase as headerCaseString,\n} from \"change-case\";\nimport { applyCaseOptions, preserveSpecificKeys } from \"./decorators\";\nimport { isFormData, isTransformable, isURLSearchParams } from \"./util\";\nimport {\n  CaseFunction,\n  CaseFunctions,\n  CaseFunctionTypes,\n  CreateObjectTransformer,\n  CreateObjectTransformerOf,\n  CreateObjectTransformers,\n  ObjectTransformerOptions,\n  ObjectTransformers,\n  Transformable,\n} from \"./types\";\n\nconst caseFunctions: CaseFunctions = {\n  snake: snakeCaseString,\n  camel: camelCaseString,\n  header: headerCaseString,\n};\n\nconst transformObjectUsingCallbackRecursive = (\n  data: unknown,\n  fn: CaseFunction,\n  overwrite: ObjectTransformerOptions[\"overwrite\"]\n): unknown => {\n  if (!isTransformable(data)) {\n    return data;\n  }\n\n  /* eslint-disable no-console */\n  // Check FormData/URLSearchParams compatibility\n  if (\n    (isFormData(data) || isURLSearchParams(data)) &&\n    (!data.entries || (overwrite && !data.delete))\n  ) {\n    const type = isFormData(data) ? \"FormData\" : \"URLSearchParams\";\n    const polyfill = isFormData(data)\n      ? \"https://github.com/jimmywarting/FormData\"\n      : \"https://github.com/jerrybendy/url-search-params-polyfill\";\n    if (\n      typeof navigator !== \"undefined\" &&\n      navigator.product === \"ReactNative\"\n    ) {\n      // You cannot transform FormData/URLSearchParams on React Native\n      console.warn(\n        `Be careful that ${type} cannot be transformed on React Native. If you intentionally implemented, ignore this kind of warning: https://facebook.github.io/react-native/docs/debugging.html`\n      );\n    } else {\n      if (!data.entries) {\n        // You need to polyfill `entries` method\n        console.warn(\n          `You must use polyfill of ${type}.prototype.entries() on Internet Explorer or Safari: ${polyfill}`\n        );\n      }\n      if (overwrite && !data.delete) {\n        // You need to polyfill `delete` method for overwriting\n        console.warn(\n          `You must use polyfill of ${type}.prototype.delete() on Internet Explorer or Safari: ${polyfill}`\n        );\n      }\n    }\n    return data;\n  }\n  /* eslint-enable no-console */\n\n  const prototype = Object.getPrototypeOf(data);\n\n  // Storage of new values.\n  // New instances are created when overwriting is disabled.\n  const store: Transformable = overwrite\n    ? data\n    : !prototype\n    ? Object.create(null)\n    : new prototype.constructor();\n\n  // We need to clean up all entries before overwriting.\n  let series:\n    | Iterable<[unknown, unknown]>\n    | IterableIterator<[unknown, unknown]>;\n  if (isFormData(data) || isURLSearchParams(data)) {\n    // Create native iterator from FormData/URLSearchParams\n    series = data.entries();\n    if (overwrite) {\n      // When overwriting, native iterator needs to be copied as array.\n      series = [...series];\n      for (const [key] of series) {\n        data.delete(key as string);\n      }\n    }\n  } else {\n    // Create array from objects\n    series = Object.entries(data);\n    // Array keys never change, so we don't need to clean up\n    if (overwrite && !Array.isArray(data)) {\n      for (const [key] of series) {\n        delete data[key as string];\n      }\n    }\n  }\n\n  for (const [key, value] of series) {\n    if (isFormData(store) || isURLSearchParams(store)) {\n      store.append(fn(key as string), value as string & File);\n    } else if (key !== \"__proto__\") {\n      store[\n        fn(typeof key === \"string\" ? key : `${key}`)\n      ] = transformObjectUsingCallbackRecursive(value, fn, overwrite);\n    }\n  }\n  return store;\n};\nconst transformObjectUsingCallback = (\n  data: unknown,\n  fn: CaseFunction,\n  options?: ObjectTransformerOptions\n): unknown => {\n  fn = applyCaseOptions(fn, {\n    stripRegexp: /[^A-Z0-9[\\]]+/gi,\n    ...options?.caseOptions,\n  });\n  if (options?.preservedKeys) {\n    fn = preserveSpecificKeys(fn, options.preservedKeys);\n  }\n  return transformObjectUsingCallbackRecursive(\n    data,\n    fn,\n    options?.overwrite || false\n  );\n};\n\nexport const createObjectTransformer: CreateObjectTransformer = (fn) => {\n  return (data, options): ReturnType<ReturnType<CreateObjectTransformer>> => {\n    return transformObjectUsingCallback(data, fn, options);\n  };\n};\nexport const createObjectTransformerOf: CreateObjectTransformerOf = (\n  functionName,\n  options\n) => {\n  return createObjectTransformer(\n    options?.[functionName] || caseFunctions[functionName]\n  );\n};\nexport const createObjectTransformers: CreateObjectTransformers = (options) => {\n  const functionNames = Object.keys(caseFunctions) as CaseFunctionTypes[];\n  const objectTransformers = {} as ObjectTransformers;\n  for (const functionName of functionNames) {\n    objectTransformers[functionName] = createObjectTransformerOf(\n      functionName,\n      options\n    );\n  }\n  return objectTransformers;\n};\n","import { __assign } from \"tslib\";\nimport { dotCase } from \"dot-case\";\nexport function snakeCase(input, options) {\n    if (options === void 0) { options = {}; }\n    return dotCase(input, __assign({ delimiter: \"_\" }, options));\n}\n//# sourceMappingURL=index.js.map","import { __assign } from \"tslib\";\nimport { noCase } from \"no-case\";\nexport function dotCase(input, options) {\n    if (options === void 0) { options = {}; }\n    return noCase(input, __assign({ delimiter: \".\" }, options));\n}\n//# sourceMappingURL=index.js.map","import { __assign } from \"tslib\";\nimport { capitalCase } from \"capital-case\";\nexport function headerCase(input, options) {\n    if (options === void 0) { options = {}; }\n    return capitalCase(input, __assign({ delimiter: \"-\" }, options));\n}\n//# sourceMappingURL=index.js.map","import { createObjectTransformers } from \"./transformers\";\nimport { isPlainObject } from \"./util\";\nimport {\n  ApplyCaseMiddleware,\n  CreateAxiosInterceptor,\n  CreateAxiosTransformer,\n  TransformableObject,\n} from \"./types\";\n\nexport const createSnakeParamsInterceptor: CreateAxiosInterceptor = (\n  options?\n) => {\n  const { snake } = createObjectTransformers(options?.caseFunctions);\n  return (config): ReturnType<ReturnType<CreateAxiosInterceptor>> => {\n    if (config.params) {\n      config.params = snake(config.params, options);\n    }\n    return config;\n  };\n};\nexport const createSnakeRequestTransformer: CreateAxiosTransformer = (\n  options?\n) => {\n  const { snake, header } = createObjectTransformers(options?.caseFunctions);\n  return (\n    data: unknown,\n    headers?: unknown\n  ): ReturnType<ReturnType<CreateAxiosTransformer>> => {\n    if (!options?.ignoreHeaders && isPlainObject(headers)) {\n      for (const [key, value] of Object.entries(headers)) {\n        header(value, { overwrite: true, ...options });\n        if (\n          ![\"common\", \"delete\", \"get\", \"head\", \"post\", \"put\", \"patch\"].includes(\n            key\n          )\n        ) {\n          delete headers[key];\n          headers[\n            Object.keys(\n              header({ [key]: null }, options) as TransformableObject\n            )[0]\n          ] = value;\n        }\n      }\n    }\n    return snake(data, options);\n  };\n};\nexport const createCamelResponseTransformer: CreateAxiosTransformer = (\n  options?\n) => {\n  const { camel } = createObjectTransformers(options?.caseFunctions);\n  return (\n    data: unknown,\n    headers?: unknown\n  ): ReturnType<ReturnType<CreateAxiosTransformer>> => {\n    if (!options?.ignoreHeaders) {\n      camel(headers, { overwrite: true, ...options });\n    }\n    return camel(data, options);\n  };\n};\n\nexport const applyCaseMiddleware: ApplyCaseMiddleware = (axios, options?) => {\n  axios.defaults.transformRequest = [\n    options?.caseMiddleware?.requestTransformer ||\n      createSnakeRequestTransformer(options),\n    ...(Array.isArray(axios.defaults.transformRequest)\n      ? axios.defaults.transformRequest\n      : axios.defaults.transformRequest !== undefined\n      ? [axios.defaults.transformRequest]\n      : []),\n  ];\n  axios.defaults.transformResponse = [\n    ...(Array.isArray(axios.defaults.transformResponse)\n      ? axios.defaults.transformResponse\n      : axios.defaults.transformResponse !== undefined\n      ? [axios.defaults.transformResponse]\n      : []),\n    options?.caseMiddleware?.responseTransformer ||\n      createCamelResponseTransformer(options),\n  ];\n  axios.interceptors.request.use(\n    options?.caseMiddleware?.requestInterceptor ||\n      createSnakeParamsInterceptor(options)\n  );\n  return axios;\n};\n"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","lowerCase","str","toLowerCase","DEFAULT_SPLIT_REGEXP","DEFAULT_STRIP_REGEXP","noCase","input","options","_a","splitRegexp","_b","stripRegexp","_c","transform","_d","delimiter","result","replace","start","end","charAt","slice","split","map","join","re","value","RegExp","reduce","pascalCaseTransform","index","firstChar","lowerChars","substr","toUpperCase","camelCaseTransform","capitalCaseTransform","upperCaseFirst","isURLSearchParams","URLSearchParams","isFormData","FormData","isPlainObject","_typeof","toString","caseFunctions","snake","dotCase","camel","pascalCase","header","capitalCase","transformObjectUsingCallbackRecursive","data","fn","overwrite","Array","isArray","isTransformable","entries","type","polyfill","navigator","product","console","warn","series","getPrototypeOf","store","constructor","create","key","append","transformObjectUsingCallback","defaultOptions","applyCaseOptions","caseOptions","preservedKeys","keys","condition","includes","preserveSpecificKeys","createObjectTransformerOf","functionName","createObjectTransformers","objectTransformers","createSnakeRequestTransformer","headers","ignoreHeaders","createCamelResponseTransformer","axios","defaults","transformRequest","caseMiddleware","requestTransformer","undefined","transformResponse","responseTransformer","interceptors","request","use","requestInterceptor","config","params","createSnakeParamsInterceptor"],"mappings":"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"}